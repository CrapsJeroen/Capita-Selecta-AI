\section{Implementation}
\label{chapter:implementation}
This section outlines how the algorithms are implemented. All the code is written in Java 8.
\par
 The first algorithm reads a graph from a text file and generates useful data structures for this graph. Afterwards, it searches for cliques in the graph and combines the vertices in those cliques into a single vertex. This reduces the amount of vertices and edges in the graph.
\par
The second algorithm takes a graph and divides it into communities using a genetic algorithm. It uses several genetic operators, including a special self-learning operator.
\subsection{Clique algorithm}
Before we can describe the clique algorithm, we will describe the data structures used by this algorithm. A Graph object is a collection of Vertex objects and Edge objects. An edge connects two vertices and also contains a weight value. When a graph is imported, these weights are usually equal to one. However, when the algorithm replaces vertices with cliques, edges with higher weights will be constructed. 
\par
When the algorithm finds a clique, the vertices in that clique will be replaced by a Clique object. All edges to members of that clique are replaced by edges to the clique as a whole. This often leads to duplicate edges, which is modelled using the edge weight. This allows the algorithm to significantly reduce the amount of edges and vertices in the graph, while preserving all relevant information about the structure of the graph.
\par

The Clique algorithm randomly samples vertices from the graph. From this sample point, the largest clique containing it is generated by following the edges to its neighbors.

\subsection{Genetic Algorithm}
\subsubsection{Core}
\subsubsection{Split/Merge Neighborhood Competition Operator}
\subsubsection{Hybrid Neighborhood Crossover Operator}
\subsubsection{Adaptive Mutation Operator}
\subsubsection{Self-Learning Operator}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
