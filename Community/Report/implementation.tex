\section{Implementation}
\label{sec:implementation}
This section outlines how the algorithms are implemented. All the code is written in Java 8.
\par
 The first algorithm reads a graph from a text file and generates useful data structures for this graph. Afterwards, it searches for cliques in the graph and combines the vertices in those cliques into a single vertex. This reduces the amount of vertices and edges in the graph.
\par
The second algorithm takes a graph and divides it into communities using a genetic algorithm. It uses several genetic operators, including a special self-learning operator.
\subsection{Clique algorithm}
Before we can describe the clique algorithm, we will describe the data structures used by this algorithm. A Graph object is a collection of Vertex objects and Edge objects. An edge connects two vertices and also contains a weight value. When a graph is imported, these weights are usually equal to one. However, when the algorithm replaces vertices with cliques, edges with higher weights will be constructed. 
\par
When the algorithm finds a clique, the vertices in that clique will be replaced by a Clique object. All edges to members of that clique are replaced by edges to the clique as a whole. This often leads to duplicate edges, which is modeled using the edge weight. This allows the algorithm to significantly reduce the amount of edges and vertices in the graph, while preserving all relevant information about the structure of the graph.
\par
Cliques are found by randomly sampling vertices from the graph. For each of the neighbors of this selected vertex, the following iterative function is executed:
\\
\begin{algorithmic}
\STATE $clique \leftarrow \{sampleVertex\}$
\STATE $done \leftarrow \{sampleVertex, neighbor\}$
\STATE $todo \leftarrow \{neighbor\}$
\WHILE{$todo$ is not empty}
\STATE $V \in todo$
\STATE $todo \leftarrow todo \backslash \{V\}$
\IF{$clique \subseteq neighbors(V)$}
\STATE $clique \leftarrow clique \cup \{V\}$
\STATE $todo \leftarrow todo \cup (neighbors(V) \backslash done )$
\STATE $done \leftarrow done \cup(neighbors(V)$
\ENDIF
\ENDWHILE
\IF{$\left|clique\right| \geq Min$ }
\RETURN{$clique$}
\ELSE
\RETURN{$\{\}$}
\ENDIF
\end{algorithmic}

This function starts adding the sampled vertex to the $clique$ set, the neighbor to the $todo$ queue, and both to the $done$ set. Afterwards, it keeps looping until the queue is empty and returns $clique$ as the result. During each cycle of the loop, vertex $V$ is taken from the queue. If $clique$ is a subset of the neighbors of $V$, the $clique$ can be extended with $V$. The $todo$ queue is extended with every neighbor of $V$ that is not in the $done$ set. Finally, to make sure each vertex can only be added to the $todo$ queue once, every neighbor of $V$ is added to the $done$ queue. If the clique is not larger than $Min$ elements, an empty set is returned.
\par
This function is executed for every neighbor of the sampled vertex. The largest clique produced this way is selected. If all cliques are empty, pick another sample and repeat. The algorithm is stopped after a maximum amount of iterations, or if no clique could be constructed for a certain amount of iterations.
\par
 To replace the vertices in the largest clique with a \textbf{Clique}\footnote{In this section, when referencing the object, and not the set of vertices, \textbf{Clique} will be in \textbf{bold}.} object. the following steps are followed:
\begin{algorithmic}[1]
\STATE Build a $neighbors$ set containing all vertices that are neighbors to a vertex in $clique$
\STATE This set will contain the vertices which are elements of $clique$ as well, remove those from $neighbors$
\STATE Construct the $\textbf{Clique}$ object, with $neighbors$ as its neighbors. Note that when multiple vertices in $clique$ share a neighbor, the edge connecting \textbf{Clique} to that neighbor has a weight equal to the sum of the weights of the edges to that neighbor.
\STATE Remove all vertices in $clique$, and all edges connected to those, from the graph.
\end{algorithmic}
\par
For performance reasons, each vertex keeps track of its own edges. During the execution of this algorithm there is no global set containing all edges. This means that whenever an edge is added or removed, this action needs to take place on both sides of that edge. To make sure this happens correctly at sufficient speed, special care needs to be taken. When the algorithm terminates, the complete set of edges is calculated by looping over all the vertices.
\subsection{Genetic Algorithm}
\subsubsection{The Jenetics library}
To implement the genetic algorithm, we decide to use a library to help with the basic structure of the algorithm. The library we used is ``Jenetics''\footnote{\url{http://jenetics.io/}} version 3.7.0. This is a modern library making full use of the features of Java 8 like Streams and Lambda functions. Our hope was that this would speed up development time by allowing us to focus on the implementation of the fitness function and genetic operators. 
\par
However, the library turned out to be just a little bit too inflexible to deal with a lattice structure. More specifically: The ``Engine'' class that drives the flow of the algorithm is marked as a final class so we could not extend it to our wishes..The full use of Java's features made things a bit harder in this case. Since the other parts of the library still seemed very useful, and the library is open source, we decided to copy the ``Engine'' class (and some other related classes) to our project so we can access and modify them to our needs. 
\par
Quite a bit of time was spent understanding and modifying this library to our needs. In hindsight we should probably have looked for another library, but at the time solving the final hurdle always seemed right around the corner.
\subsubsection{Core}
\subsubsection{Split/Merge Neighborhood Competition Operator}
\subsubsection{Hybrid Neighborhood Crossover Operator}
\subsubsection{Adaptive Mutation Operator}
\subsubsection{Self-Learning Operator}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "masterproef"
%%% End: 
